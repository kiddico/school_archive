newman is teaching :D
    
    temlpate <typename T>
    void swap(T right, T left){...}
    
Making a Generic Array Template
template <template T>
class Array{
    publc:
        Array();//regular constructor need this
        Array(const Array<T>&);//copy nees this too
        Array& operator = (Array <T>);//this thing need this too
        ~Array();
        void swap(Array <T>&);
        Array(int, const Array<T>);
    
    private:
        T *ptr;
        int cap;
}

//EVERYTHING BELOW HERE IS LABELED CORRECTLY, DO NOT FUCK IT UP
////aww man I was totally looking forward to fucking it up
/////////////////////this is the CPP

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//need this above every method

template <typename T>
    METHOD!!!(){...}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//default constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Array<T>::Array(){
    ptr;
    //could have 
    //ptr=new T[100];
    //cap=100;
    cap=0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//now we want to write a function "initialize"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Array<T>:: Array(int size){
    ptr=new <T>[size];
    cap=size;
    
    //one step further
    //INCLUDE THIS
    /*
    for(int i=0;i<size;++i){
        ptr[i]=0;
        //this initializes the array to all zeros
        //we could also do this with a function
    }
    */
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//COPY CONSTRUCTOR
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Array<T>:: Array(const Arrary<T>& rhs){
    ptr=new T[rhs.cap];
    cap=rhs.cap;
    for(int i=0;i<rhs.cap;++i){
        ptr[i]=rhs.ptr[i];
    }
}
//this would call the copy const
//Array<int> Arr;
//Array<int>Arr2=Arr;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//swap
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Array<T>::swap(Array<T>& rhs){
    T *ptr tmp=rhs.ptr;
    rhs.ptr=this->ptr;
    this->ptr=ptr;//or tmp->ptr if it shits itself
    int tmp=rhs.cap;
    rhs.cap=this->cap;
    this->cap=tmp->cap;
    //hey! there we go!
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//operator =
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Array<T>& Array<T>::operator =(Array<T> rhs){
    //first check for self assignment
    //this is onlt necessary if rhs was being passed as const
    //pretty much we just don't need this
    //tardo is just talking for hte sake of talking
    ////////////////////if(this->ptr==rhs.ptr){return *this;}
    //seriously though can we duct tape his mouth before class?
    //NOTHING ABOVE THIS MATTERS AT ALL...at least... you know what I mean. asshole
    swap(rhs);
    return *this
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Destructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Array<T>::~Array(){
    delete[] ptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//"I mean we cal look at things like subscript if you want" 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//we need 2 subscript operators


//this one just reads I believe
//this is always called if the variable called into it with is also const
T operator [](const int index)const{
    if(index<cap){
            return ptr[index];}
    if(index>cap){std::cout<<"fuck off"<<std::endl;}
}
/*
    like this^^^^^^
    
    const Array<T> Arr;
    Arr[i];
*/

//this one does oher thigns

T& operator[](const int index){
    //ok.... not going to go about explainging this one...
    //oh wait yeah. he said it's the same thing....
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//more on templates
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//say that we put all those things in array.cpp^^^^^^^^^^^^^^^^
//now over in main...

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//main.cpp

int main(){
    Array<int> Arr;
    std::cout<<arr;
}
//now why is that int a problem?
//to solve this problem
//define methonds in the hpp files.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////